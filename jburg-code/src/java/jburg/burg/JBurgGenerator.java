package jburg.burg;

//  BURM specification is parsed into ANTLR AST objects.
import antlr.collections.AST;
//  The code emitter interface definition.
import jburg.emitter.EmitLang;
// The code emitter works by string templates.
import org.antlr.stringtemplate.*;

//  The factory that selects and creates an emitter.
import jburg.emitter.JBurgEmitterFactory;

//  The i-node adapter interface definition.
import jburg.burg.inode.InodeAdapter;

//  Intermediate representation classes.
import jburg.burg.ir.*;

//  The factory that selects and creates an I-node adapter.
import jburg.burg.inode.InodeAdapterFactory;
//  The pseudo-adapter explicitly instantiated
//  by inline adapater declarations.
import jburg.burg.inode.InlineInodeAdapter;
//  Interface for i-node adapters that need
//  to emit support routines into generated source.
import jburg.burg.inode.InodeAuxiliarySupport;

// Utility routines.
import static jburg.burg.JBurgUtilities.*;

//  Token types from ANTLR.
import jburg.parser.JBurgTokenTypes;

//  Version file, generated by build.
import jburg.version.JBurgVersion;

import java.io.PrintStream;
import java.io.PrintWriter;

import java.lang.reflect.Modifier;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;


@SuppressWarnings("nls")
public class JBurgGenerator implements JBurgTokenTypes
{
    /**
     *  The JBurg specification's rules are categorized as:
     *  <ul>
     *  <li> Pattern  (e.g., integer = PLUS(integer, integer) )
     *  <li> Simple Transformational   (e.g., registerOperand  = integer)
     *  <li> Complex Transformational  (e.g., string = integer { code to convert integer to string} )
     *  </ul>
     *
     *  Simple transformational rules allow a subgoal to satisfy
     *  other subgoals without additional processing; complex
     *  transformational rules allow one subgoal to feed additional
     *  processing that can satisfy other subgoals (at added cost).
     *
     *  Syntactically, a simple transformational rule is distinguished 
	 *  by its lack of a block of code.
	 *  Simple transformational rules are also known as "chain rules"
	 *  in simpler BURGs that don't support complex transformational
	 *  rules.  This longer name was adopted to highlight that difference,
	 *  but a simple transformational rule is, in fact, a chain rule
	 *  by a different name.
     */

	/**
     *   The table of all transformation rules; keyed
     *   by the rules' antecedent state, e.g., integer
	 *   in the rule number = integer).
     */
    Map<String, Vector<JBurgRule>> transformationRules = new HashMap<String, Vector<JBurgRule>>();

	/**
	 *  The table of all pattern rules, keyed
	 *  by the top-level operator of the pattern,
	 *  e.g., PLUS in the pattern integer = PLUS(integer, integer).
	 */
    Map<String, Vector<JBurgRule>> patternRules = new HashMap<String, Vector<JBurgRule>>();

    /**
     *  Closure sets, keyed by their goal state.
     */
    Multimap<String, ClosureRecord> closureSets = new Multimap<String, ClosureRecord>();

    /**
     *  Action code fragments.
     */
    ArrayList<JBurgReduceAction> reduceActions = new ArrayList<JBurgReduceAction>();

    /**
     *  Table of properties to be added to the BURM.
     *  Each one is a name/type pair; the BURM gets
     *  a private member and get/set methods.
     */
    Map<String, Object> burmProperties = new HashMap<String, Object>();

    /**
     *  Simple transformations delegate to their antecedent reduction,
     *  so all transformations to a given nonterminal state can share the
     *  same rule.
     */
    Map<String, JBurgRule> simpleTransformationRules = new HashMap<String,JBurgRule>();
    
    /** The language-specific code emitter. */
	EmitLang codeEmitter = null;

	/**  Cumulative error count. */
	int errCount = 0;

    /**  Prologue snippets mapped to the corresponding rule number. */
    Map<Integer,AST> prologueBlocks = new TreeMap<Integer,AST>();

    /**
     * The master list of rules by equivalence class.
     */
    RulesByOperatorAndArity annotationsByEquivalenceClass = new RulesByOperatorAndArity(this);

    /**
     *  Manifest constants in the JBurg specification.
     */
    Map<String,Integer> manifestConstants = new HashMap<String,Integer>();
    
    /**
     *  Manifest constant for method declarations.
     */
    final private static Class<?>[] throwsNothing = null;

    /**
     *  Manifest constant for method declarations.
     */
    final private static Class<?>[] throwsException = new Class<?>[] { Exception.class };

    /**
     *  Manifest constant for method declarations.
     */
    final private static FormalParameter[] noFormalParameters = null;

    /**
     *  Manifest constant for an unfeasible rule.
     */
    final private static String NO_FEASIBLE_RULE = "-1";

    /**
     *  Manifest constant for an uninitialized cost.
     */
    final private static String UNINITIALIZED = "-1";

    /**
     *  NamedPattern holds a named pattern, and keeps a table of the reductions that refer to it.
     */
    class NamedPattern
    {
        String patternName;
        AST pattern = null;
        Vector<AST> reductions = new Vector<AST>();

        NamedPattern(String name)
        {
            this.patternName = name;
        }
    }

    /**
     *  A PatternMap keeps the map of pattern names to reductions.
     */
    @SuppressWarnings("serial")
    class PatternMap extends  TreeMap<String,NamedPattern>
    {
        NamedPattern getPattern(String key)
        {
            if ( !super.containsKey(key) )
                put(key, new NamedPattern(key));
            return super.get(key);
        }

        void addPattern(String key, AST pattern)
        {
            NamedPattern p = getPattern(key);
            p.pattern = pattern;
        }

        void addReduction(String key, AST reduction)
        {
            NamedPattern p = getPattern(key);
            p.reductions.add(reduction);
        }
    }

    /**
     * Patterns declared separately from the
     * reduction(s) that use them, e.g.,
     * Pattern callMethod = CALL(expression method, expression parameters*);
     * expression = Pattern callMethod: cost1
     * void_expression = Pattern callMethod: cost2
     */
    PatternMap namedPatterns = new  PatternMap();

    /**
     * The active configuration.
     */
    public Configuration config;

    /**
     *  @param root - the root of the AST generated by parsing the .jburg specification.
     *  @param log - a sink for diagnostics.
     */
    public JBurgGenerator(AST root, Logger log, Options options) throws Exception
    {

        // Inline declarations of I-node logic.
        AST inlineGetOperator = null;
        AST inlineGetChildCount = null;
        AST inlineGetChild = null;

        this.config = new Configuration(options);
        config.logger = log;

        //  Walk over the children of the root, each of which 
		//  is a self-contained syntactical construct, and
        //  perform the appropriate action for each.
        for (AST currentNode = root; currentNode != null;
                currentNode = currentNode.getNextSibling()) 
		{
            switch (currentNode.getType()) 
			{
            case COST_FUNCTION:
                config.costFunctions.add(createCostFunction(currentNode));
                break;

            case HEADER_DECLARATION:

				if (config.headerBlock == null) {

					config.headerBlock = getCodeBlock(currentNode);
				} else {
                    throw new IllegalArgumentException("The class header may only be specified once.");
				}
                break;
                
            case INCLASS_DECLARATION: {
            		config.inclassCode.add( stripBrackets(getCodeBlock(currentNode)) );
            	}
				break;

            case INODE_ADAPTER_DECLARATION:

                if (config.iNodeAdapterClass == null) {

					config.iNodeAdapterClass = getIdentifierText(currentNode.getFirstChild());
				} else {
                    throw new IllegalArgumentException("INodeAdapter may only be specified once.");
				}

				break;

            case INODE_TYPE_DECLARATION:

                if (config.iNodeClass == null) {

                    config.iNodeClass = getIdentifierText(currentNode.getFirstChild());
				} else {
                    throw new IllegalArgumentException("INodeType may only be specified once.");
				}
                break;
                
            case LANGUAGE_DECLARATION:

            	if ( null == config.emitLanguageName ) {

            		config.emitLanguageName = currentNode.getFirstChild().getText();
				} else {
            		throw new IllegalArgumentException("Language may only be specified once.");
				}
            	break;

            case EXTENDS_CLASS_SPECIFICATION:
                config.baseClassName = getIdentifierText( currentNode.getFirstChild());
                break;

            case IMPLEMENTS_INTERFACE_SPECIFICATION:
                config.interfaceNames.add(getIdentifierText( currentNode.getFirstChild()) );
                break;

            case PACKAGE_SPECIFICATION:

                if ( null == config.packageName ) {

					config.packageName = getIdentifierText(currentNode.getFirstChild());
				} else {
            		throw new IllegalArgumentException("package may only be specified once.");
				}
                break;

            case PROPERTY_SPECIFICATION: {
					String propertyType = getIdentifierText(currentNode.getFirstChild());
					String propertyName = currentNode.getFirstChild().getNextSibling().getText();
					this.burmProperties.put(propertyName, propertyType);
				}
                break;

            case RETURN_DECLARATION:

                if (config.defaultReturnType == null) {
                    config.defaultReturnType = getIdentifierText(currentNode.getFirstChild());
                    config.returnTypes.add(config.defaultReturnType);
                } else if (config.defaultReturnType == Configuration.STRICT_RETURN_TYPE) {
                    throw new IllegalArgumentException( "When StrictReturnType is specified, ReturnType must specify a state name");
                } else {
                    throw new IllegalArgumentException( "ReturnType may only be specified once.");
                }
                break;

            case STRICT_TYPE:
                if (config.defaultReturnType == null || config.defaultReturnType == Configuration.STRICT_RETURN_TYPE) {
                    config.defaultReturnType = Configuration.STRICT_RETURN_TYPE;
                } else {
                    throw new IllegalArgumentException( "ReturnType declaration with default (empty) state conflicts with StrictReturnType declaration.");
                }
                break;

            case WILDCARD_STATE:
                    config.wildcardState = getIdentifierText(currentNode.getFirstChild());
                    config.goalStateNames.add(config.wildcardState);
                    // Add the mapping of wildcard state to inode type once all elements have been processed.
                break;

            case REDUCER_NODE_NAME:
                    config.reducerNodeName = getIdentifierText(currentNode.getFirstChild());
                break;

            case PATTERN_RULE:
                addPatternRule(currentNode);
                break;

            case SIMPLE_TRANSFORMATION_RULE:
                addSimpleTransformationRule(currentNode);
                break;

            case TRANSFORMATION_RULE:
                addComplexTransformationRule(currentNode);
                break;

            case TYPED_RETURN_DECLARATION: {

                    String stateName = currentNode.getFirstChild().getText();
                    String returnType = getIdentifierText(currentNode.getFirstChild().getNextSibling());

                    //  Put the return declaration in the table, but only once per state.
                    Object typeCollision = config.returnTypeTable.put(stateName, returnType);
                    if ( null != typeCollision ) {
                        throw new IllegalArgumentException(
                            "A state may only specify one ReturnType."
                        );
                    }
                    config.returnTypes.add(returnType);
                }
                break;

            case PATTERN_DECLARATION: {

                    String pattern_name = currentNode.getFirstChild().getText();
                    namedPatterns.addPattern(pattern_name, currentNode);
                }
                break;

            case REDUCTION_DECLARATION: {

                    String pattern_name = currentNode.getFirstChild().getNextSibling().getText();
                    namedPatterns.addReduction(pattern_name, currentNode);
                }
                break;

            case DEFAULT_ERROR_HANDLER:
                config.defaultErrorHandler = getCodeBlock(currentNode);
                break;

            case NODE_TYPE: {

                final String operatorID = currentNode.getFirstChild().getText();
                assert !operatorID.isEmpty() : "Parser should never create empty operator!";
                final String nodeType = currentNode.getFirstChild().getNextSibling().getText();               
                assert !nodeType.isEmpty() : "Parser should never create empty node type!";
                
                if (config.opcodeNodeTypes.put(operatorID, nodeType) != null) {
                    throw new IllegalArgumentException(String.format("Duplicate node type declaration for '%s'", operatorID));
                }
                break;
            }
            case OPCODE_TYPE:
                config.opcodeType = currentNode.getFirstChild().getText();
                break;

            case NON_TERMINAL_ENUM:
                config.ntType = currentNode.getFirstChild().getText();
                break;

            case MANIFEST_CONSTANT:
                manifestConstants.put(currentNode.getFirstChild().getText(), Integer.parseInt(currentNode.getFirstChild().getNextSibling().getText()));
                break;

            case VOLATILE_COST:

                for ( AST volatileCost = currentNode.getFirstChild().getNextSibling(); volatileCost != null; volatileCost = volatileCost.getNextSibling() ) {
                    config.volatileCostFunctions.add(volatileCost.getText());
                }
                break;

            case OPTION_SETTING: {

            	String optionName = currentNode.getFirstChild().getText();
            	String optionValue = currentNode.getFirstChild().getNextSibling().getText();
            	
            	if ( optionName.equalsIgnoreCase("ignoreNullInode")) {
            		config.generateNullTolerantLabeller = optionValue.equalsIgnoreCase("true");
            	}
            	break;
            }

            case GET_CHILD:
                inlineGetChild = currentNode;
                break;
            case GET_OPERATOR:
                inlineGetOperator = currentNode;
                break;
            case GET_COUNT:
                inlineGetChildCount = currentNode;
                break;

            case ALLOCATOR:
                config.allocator = currentNode.getFirstChild().getText();
                break;

            case ANNOTATION_EXTENDS:
                config.annotationBaseClassName = currentNode.getFirstChild().getText();
                break;

            case ANNOTATION_DECLARATION: {

                AST getDeclaration = currentNode.getFirstChild();
                AST setDeclaration = getDeclaration.getNextSibling();

                config.annotationAccessor = new AnnotationAccessor(
                    getDeclaration.getFirstChild().getText(),
                    getDeclaration.getFirstChild().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getNextSibling().getText(),
                    setDeclaration.getFirstChild().getNextSibling().getNextSibling().getNextSibling().getText()
                );
                break;
            }

            case INIT_STATIC_ANNOTATION:
                config.initStaticAnnotation = currentNode.getFirstChild().getText();
                break;

            default:
                throw new IllegalArgumentException("Unknown specification AST type " +
            											String.valueOf(currentNode.getType()));
            }
        }

        //  Set the language emitter.
        codeEmitter = JBurgEmitterFactory.getEmitter(config.emitLanguageName, config.getLogger());

        if ( codeEmitter != null ) {
            codeEmitter.setConfiguration(config);
            codeEmitter.setINodeType(config.iNodeClass);
            codeEmitter.setAllocator(config.allocator);
            codeEmitter.setAnnotationAccessor(config.annotationAccessor);
            codeEmitter.setOpcodeType(config.opcodeType);
            codeEmitter.setDefaultAttribute("annotationClass", null);
		} else {
			throw new IllegalStateException("Unknown language specified: \""+ config.emitLanguageName +"\"");
        }

        if (inlineGetChild != null || inlineGetOperator != null || inlineGetChildCount != null) {

            if (inlineGetChild == null || inlineGetOperator == null || inlineGetChildCount == null) {
                throw new IllegalStateException("@getChild, @getOperator, and @getChildCount must all be specified.");
            }

            config.iNodeAdapter = new InlineInodeAdapter(
                inlineGetOperator.getFirstChild().getNextSibling().getText(),
                inlineGetOperator.getFirstChild().getText(),
                inlineGetChild.getFirstChild().getNextSibling().getNextSibling().getText(),
                inlineGetChild.getFirstChild().getText(),
                inlineGetChild.getFirstChild().getNextSibling().getText(),
                inlineGetChildCount.getFirstChild().getNextSibling().getText(),
                inlineGetChildCount.getFirstChild().getText()
            );
        } else if ( config.iNodeClass != null ) {

            // If an i-node adapter was specified by class name, instantiate an instance.
            // Otherwise, get an adapter from the factory's known instances.
			if ( config.iNodeAdapterClass != null ) {
				try {
					config.iNodeAdapter = (InodeAdapter)Class.forName(config.iNodeAdapterClass).newInstance();
				} catch ( Exception ex ) {
					config.logger.exception("loading i-node adapter", ex);
                    config.logger.error("Unable to instantiate i-node adapter %s", config.iNodeAdapterClass);
				}
			} else {
				config.iNodeAdapter = InodeAdapterFactory.getAdapter(config.iNodeClass, config.logger);
			}
			
			codeEmitter.setINodeType(config.iNodeClass);

			if ( config.iNodeAdapter != null ) {
				config.logger.info("Using i-node adapter %s\n", config.iNodeAdapter.getClass().getName() );
			} else {
				config.getLogger().warning("Using default i-node adapter, no adapter matches %s\n", config.iNodeClass );
				config.iNodeAdapter = new jburg.burg.inode.DefaultAdapter();
			}
		} else {
			config.logger.error("You must specify the i-node type.\n");
		}

        if ( config.logger.getErrorCount() > 0 )
            return;

		codeEmitter.setInodeAdapter(config.iNodeAdapter);
        codeEmitter.setNtType(config.ntType);

        //  Default return type is the same as the INode class.
        if (config.defaultReturnType == null)
		{
            config.defaultReturnType = config.iNodeClass;
		}

        // Coerce the wildcard state's return type to the INode class.
        if (config.wildcardState != null) {
            Object typeCollision = config.returnTypeTable.put(config.wildcardState, config.iNodeClass);
            if ( null != typeCollision ) {
                throw new IllegalArgumentException("A state may only specify one ReturnType.");
            }
            config.returnTypes.add(config.iNodeClass);
        }

        //  Expand pattern/reduction pairs into pattern rules.
        for ( NamedPattern np: namedPatterns.values() )
        {
            if ( np.pattern != null && np.reductions.size() > 0 )
            {
                AST named_pattern = np.pattern.getFirstChild().getNextSibling().getFirstChild();

                for ( AST reduction: np.reductions )
                {    
                    //  Splice the pattern into the reduction AST.
                
                    AST nt_state = reduction.getFirstChild();
                    AST pattern_name = nt_state.getNextSibling();
                    AST cost_decl = pattern_name.getNextSibling();
                    
                    //  Create a new holder for the pattern
                    //  so the original AST isn't mutated.
                    AST pattern_holder = new antlr.CommonAST();
                    pattern_holder.setFirstChild(named_pattern);
                    nt_state.setNextSibling(pattern_holder);
                    pattern_holder.setNextSibling(cost_decl);
    
                    //  Give the composite AST the appropriate type
                    //  for its pattern.
                    reduction.setType(PATTERN_RULE);
    
                    addPatternRule(reduction);
                }
            }
            else if ( np.pattern != null )
            {
                config.getLogger().warning("pattern %s has no reduction - ignored.\n", np.patternName );
            }
            else if ( np.reductions.size() > 0 )
            {
                throw new IllegalStateException("Reduction " + np.patternName + " has no associated pattern.");
            }
        }

        //  Add target-specific logic to the simple transformations' rules.
        for ( JBurgRule rule: this.simpleTransformationRules.values() ) {
            JBurgReduceAction action = addAction(rule, rule.getGoalState());
            action.setAntecedentState(rule.getAntecedentState());
        }
    }
    
    /**
     *  Add a reduce action to the action list.
	 *  Actions are keyed by number in the generated BURM.
     *  @param action - the rule that uses this action.
     *  @param goalState - the nonterminal state that represents
     *  the result of this reduction.
     */
    private JBurgReduceAction addAction(JBurgRule rule, String goalState)
    {
        JBurgReduceAction newAction = new JBurgReduceAction(rule, goalState, this);
        rule.setReduceAction(newAction);
        this.reduceActions.add(newAction);

        //  Annotate this action with its state index:
        //  the 0th index is used as the default action for
        //  simple transformation rules, so use 1-based counting.
        newAction.setIndex(this.reduceActions.size());
        return newAction;
    }

    /**
     *  Analyze a rule's action routine specifications
     *  and extract its prologue reduction, if any.
     *  @param rule - rule.
     *  
     */
    private void extractPrologue(JBurgRule rule)
    {
        AST reduction = null;

        if ( hasASTOfType(rule.m_AST, REDUCTION_ACTION) )
            reduction = getASTByType(rule.m_AST, REDUCTION_ACTION);
        else if ( hasASTOfType(rule.m_AST, EXPLICIT_REDUCTION ) )
            reduction = getASTByType(rule.m_AST, EXPLICIT_REDUCTION);
        else
            return;
        
        if ( hasASTOfType(reduction, PROLOGUE) )
            this.prologueBlocks.put(rule.getReduceAction().index, getASTByType(reduction, PROLOGUE));
    }

    /**
     *  Add a complex transformation rule to its table,
     *  and record the rule's reduction action.
     */
    private void addComplexTransformationRule(AST transform)
        throws Exception
    {
        JBurgRule n = addNamedRule(this.transformationRules, transform);

        //  Prepare the rule's reduce action.
        JBurgReduceAction action = addAction(n, n.getGoalState());
        action.setAntecedentState(n.getAntecedentState());
        extractPrologue(n);

        //  Add the antecedent state by name as an alias action routine "parameter."
        //  The "parameter" is popped off the reduced values stack into a local variable.
        action.addParameter(
            n.getAntecedentState(), 
            n.getAntecedentState(), 
            ParameterDescriptor.ArityType.Fixed
        );
    }

    /**
     *  If this simple transformation is not yet known, add it to its rule table.
     */
    private void addSimpleTransformationRule(AST transform)
    {
        JBurgRule newRule = new JBurgRule(transform, this);

        String key = String.format("%s=%s", newRule.getGoalState(), newRule.getAntecedentState());

        if ( ! this.simpleTransformationRules.containsKey(key) )
        {
            //  Ensure this rule's nonterminal is known.
            this.config.goalStateNames.add(newRule.getGoalState());
            addNamedRule(this.transformationRules, newRule);

            //  Target-specific action logic will be
            //  added once the code emitter is up.
            this.simpleTransformationRules.put(key, newRule);
        }
    }

    /**
     *  Wrap a pattern rule in an I-node, and add it to the pattern rule table.
     */
    private void addPatternRule(AST newRule) throws Exception
    {
        JBurgRule n = addNamedRule(this.patternRules, newRule);
        addAction(n, n.getGoalState());
        extractPrologue(n);
    }

    /**
     *  Wrap a rule in an I-node, and add it to the list of rules
     *  that produce a particular subgoal.
     */
    private JBurgRule addNamedRule(Map<String, Vector<JBurgRule>> ruleTable, AST newAST)
    {
        JBurgRule newRule = new JBurgRule(newAST, this);

        //  Ensure this rule's nonterminal is known.
        this.config.goalStateNames.add( newRule.getGoalState() );
        return addNamedRule(ruleTable, newRule);
    }

    /**
     *  Add a rule to its rule table.
     *  @param ruleTable - the appropriate table for this type of rule.  Keyed by operator.
     *  @param newRule - the rule to add.
     */
    private JBurgRule addNamedRule(Map<String, Vector<JBurgRule>> ruleTable, JBurgRule newRule)
    {
        //  Store the rule by operator.
        String operator = newRule.getOperator();

        Vector<JBurgRule> vRules = ruleTable.get(operator);

        if (vRules == null)
        {
            vRules = new Vector<JBurgRule>();
            ruleTable.put(operator, vRules);
        }

        vRules.add(newRule);

        return newRule;
    }

    /**
     *  Compute the closure set of a rule:  the set of rules that
     *  that can transform this rule's goal to satsify another goal.
	 *  @note computeClosure is public so that it can be applied.
     */
    public void computeClosure(JBurgRule n) throws Exception
    {
		//  Get the list of transformation rules that can use this rule's goal state.
        Vector<JBurgRule> closureCandidates = this.transformationRules.get(n.getGoalState());

        if (closureCandidates != null) {

            for (JBurgRule nPrime:closureCandidates ) {

                ClosureRecord newClosure = new ClosureRecord(nPrime, this);

                if (!this.closureSets.getSet(n.getGoalState()).contains(newClosure)) {
                    this.closureSets.addToSet(n.getGoalState(), newClosure);
                }

            }
        }
    }

    /**
     *  Scan all the rules and compute their closure sets.
     */
    private void computeClosureSets() throws Exception
    {
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values() ) {
            applyToAll( this, patternRulesByNonterminal, "computeClosure", JBurgRule.class);
        }

        for (Vector<JBurgRule> transformations : this.transformationRules.values() ) {
            applyToAll( this, transformations, "computeClosure", JBurgRule.class);
        }
    }

    public void semanticAnalysis()
    throws Exception
    {
        // Add pattern rules' parameterized subtrees and named (terminal)
        // subtrees as pseudo-parameters to their action routines.
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values()) {

            for (JBurgRule rule: patternRulesByNonterminal) {

                for (JBurgPatternMatcher subgoal: rule.patternMatcher.getParameterizedSubtrees()) {

                    rule.getReduceAction().addParameter(
                            subgoal.getParameterName(), 
                            subgoal.getSubgoal(), 
                            subgoal.isNary()? ParameterDescriptor.ArityType.Variable: ParameterDescriptor.ArityType.Fixed
                            );
                }

                //  Add the named subtrees as a convenience.
                for ( JBurgPatternMatcher named_terminal: rule.patternMatcher.getNamedSubtrees()) {

                    rule.getReduceAction().addNamedSubtree(
                            named_terminal.generateReduceTimePath(codeEmitter, config.reducerNodeName, config.iNodeAdapter), 
                            named_terminal.getParameterName()
                            );
                }

                //  If the pattern matches an operator, send that operator
                //  to the rule so it can be matched in content-access snippets.
                if ( rule.patternMatcher.matchesOperator() )
                    rule.getReduceAction().setOperator(rule.patternMatcher.getOperator());
            }
        }
        
        for (Vector<JBurgRule> patternRules: this.patternRules.values()) {
            annotationsByEquivalenceClass.addAll(patternRules);
        }

        computeClosureSets();
        annotationsByEquivalenceClass.analyze();
    }

    /**
     *  Emit the BURG specification's resultant BURM to an output stream.
     */
    public void emit(PrintStream output)
    throws Exception
    {
        codeEmitter.setClassName(config.options.className);
        codeEmitter.setDebugMode(config.options.debug);

        emitHeader(output);
        codeEmitter.emitInclass(config.inclassCode, output);

        if ( config.iNodeAdapter instanceof InodeAuxiliarySupport ) {
            ((InodeAuxiliarySupport)config.iNodeAdapter).emitAuxiliarySupport(codeEmitter, output);
        }

        emitLabelFunction(output);
        emitActions(output);
        emitCostFunctions(output);
        emitAnnotations(output);
        emitSubgoalLookupTables(output);
        emitTrailer(output);
    }

    private void emitTrailer(PrintStream output)
    {
        //  Translate prologue blocks.
        Map<Integer, Object> translatedPrologues = new HashMap<Integer, Object>();

        for ( Integer key: this.prologueBlocks.keySet() )
        {
            AST prologue = this.prologueBlocks.get(key);

            if ( hasASTOfType(prologue, BLOCK) )
                translatedPrologues.put(key, getCodeBlock(prologue));
            else if ( hasASTOfType(prologue, PROCEDURE_CALL) )
                translatedPrologues.put(key, emitExpression(getASTByType(prologue, PROCEDURE_CALL)) + ";");
            else
                throw new IllegalStateException("Prologue block with no inline code or callback");
        }
        
        codeEmitter.emitTrailer(
            this.config.goalStateNames,
            this.burmProperties,
            config.defaultErrorHandler,
            translatedPrologues,
            output
        );
    }

    /**
     * Emit static lookup tables.
     */
    private void emitSubgoalLookupTables(PrintStream output)
    {
        Map<Integer, Vector<JBurgPatternMatcher>> rules_by_action = new HashMap<Integer,Vector<JBurgPatternMatcher>>();
        int max_action = 0;

        // Populate the rules_by_action table and find the maximum action number used by a pattern rule.
        for (Vector<JBurgRule> patternRulesByNonterminal: this.patternRules.values()) {

            for (JBurgRule p: patternRulesByNonterminal) {

                int action_number = p.getReduceAction().getIndex();
                max_action = Math.max(max_action, action_number);
                
                if ( p.patternMatcher.isNary() ) {

                    rules_by_action.put(action_number,new Vector<JBurgPatternMatcher>());
                    rules_by_action.get(action_number).add(p.patternMatcher);

                } else if (!p.patternMatcher.getParameterizedSubtrees().isEmpty() ) {

                    rules_by_action.put(action_number,p.patternMatcher.getParameterizedSubtrees());
                }
            }
        }

        //  Find the maximum action number in a pattern rule or chain rule.
        for ( Vector<JBurgRule> transformations:  this.transformationRules.values() )
            for ( JBurgRule t: transformations )
                max_action = Math.max(max_action, t.getReduceAction().getIndex());
        
        codeEmitter.emitSubgoalLookupTables(max_action, rules_by_action, output);

        //  Generate manifest constant declarations.
        for ( Map.Entry<String,Integer> constants : this.manifestConstants.entrySet() )
            output.println(
                getTemplate(
                    "constant",
                    "type", "int",
                    "name", constants.getKey(),
                    "value", constants.getValue().toString()
                )
            );
    }

    /**
      *  Emit the file/class header information.
      */
    private void emitHeader(PrintStream output)
    {
        output.println(codeEmitter.genComment(String.format(" Generated %s by JBurg version %s ", new java.util.Date(), JBurgVersion.version)));
        output.println();

        if (config.annotationAccessor != null) {
            for (AnnotationSemantics semantics: annotationsByEquivalenceClass.getSingletonAnnotations()) {
                codeEmitter.addSingletonAnnotationClass(semantics.getSpecializedClassName());
            }
        }

        codeEmitter.emitHeader(
            config.packageName,
            config.headerBlock,
            config.baseClassName,
            config.interfaceNames,
            output
        );
    }

    /**
     * @param cost a call to a cost function.
     * @return true iff the cost function is not listed as volatile.
     */
    boolean isStableCostFunction(String cost)
    {
        for ( String volatileCost: config.volatileCostFunctions )
            if ( cost.startsWith(volatileCost) )
                return false;

        return true;
    }

    /**
     * Emit code to call the action routines.
     */
	private void emitActions(PrintStream output)
	{
        // Action 0 is hard-coded noop.
		int i = 1;

		//  Print out the individual action routines.
		for (JBurgReduceAction nextAction: reduceActions )
		{
            output.println();
			output.println(codeEmitter.genComment(nextAction.getState()));
			
            //  Compute the type of the i-node.
            String typeOfOperatorINode;
			final String actionOperator = nextAction.getOperator();

			if ( config.opcodeNodeTypes.containsKey(actionOperator) )
			    typeOfOperatorINode = config.opcodeNodeTypes.get(actionOperator);
			else
			    typeOfOperatorINode = config.iNodeClass;

            StringTemplate actionRoutine = defineMethod(
				Modifier.PRIVATE,
				config.getReturnType(nextAction.getState()),
				"action_" + String.valueOf(i++),
				FormalParameter.buildFormals(typeOfOperatorINode, config.reducerNodeName),
				throwsException
			);
				
			//  Replace #goalstate with the name of the action's input node.
			String goalPattern = "#" + nextAction.getState();
			addContents(actionRoutine, nextAction.emit().replaceAll(goalPattern, config.reducerNodeName));

            output.println(actionRoutine);
		}

		//  Emit their common dispatch routine.
        String nodeName = config.annotationAccessor == null? "___node" : config.reducerNodeName;
        FormalParameter[] formals = config.annotationAccessor == null?
			FormalParameter.buildFormals(config.options.annotationInterfaceName, nodeName, "int", "iRule"):
			FormalParameter.buildFormals(config.iNodeClass, nodeName, "int", "iRule");

        StringTemplate dispatchAction =
		defineMethod(
			Modifier.PRIVATE,
			"void",
			"dispatchAction",
			formals,
			throwsException
		);

        if (config.annotationAccessor == null) {
            addLocalVar(
                dispatchAction,
                config.iNodeClass,
                config.reducerNodeName,
                this.codeEmitter.genCallMethod(nodeName, "getNode")
            );
        }

        StringTemplate dispatchSwitch = addSubTemplate(dispatchAction, "switch", "expr", "iRule");

		//  Emit the dispatch case statement.
		for (i = 1; i <= reduceActions.size(); i++) {
            JBurgReduceAction action = reduceActions.get(i-1);

            StringTemplate switchCase = addSubTemplate(
                dispatchSwitch,
                "switchCase",
                "label", String.valueOf(i)
            );

            //  If this is a nonterminal-to-nonterminal
            //  transformation, run the antecedent
            //  reduction action.
            if ( action.hasAntecedentState() ) {
                addExprStatement(
                    switchCase,
                    codeEmitter.genCallMethod(
                        "this",
                        "reduceAntecedent",
                        nodeName, codeEmitter.genGetGoalState(action.getAntecedentState())
                    )
                );
            }

            String operatorName = action.getOperator();
            String nodeTypeForOperator =
                operatorName != null ?
                    config.opcodeNodeTypes.get(operatorName):
                    null;

            Object nodeParameterString =
                nodeTypeForOperator != null?
                    codeEmitter.genCast(nodeTypeForOperator, config.reducerNodeName):
                    config.reducerNodeName;
            
            addContents(
                switchCase,
                codeEmitter.getTemplate(
                    "pushReducerIntermediate",
                    "stackName", config.reducedValuesName,
                    "valueType", config.getReturnType(action.getState()),
                    "valueExpr", this.codeEmitter.genCallMethod(
                        "this",
                        "action_" + String.valueOf(i),
                        nodeParameterString
                    )
                )
            );
		}

        StringTemplate defaultCase = codeEmitter.getTemplate("switchDefaultNoFallthrough");
        addExprStatement(defaultCase, codeEmitter.genThrow(codeEmitter.getStringIntConcat("\"Unmatched reduce action \"", "iRule")));

        addContents(dispatchSwitch, defaultCase);

		output.println(dispatchAction);
	}

    /**
     * Emit cost functions.
     */
	public void emitCostFunctions(PrintStream output) 
	{
		for (Object currentCostFunction: config.costFunctions) {
            output.println(currentCostFunction);
        }
    }

    /**
     * Decode an AST into a cost function definition.
     * @param syntax the cost function AST.
     */
    private Object createCostFunction(AST syntax)
    {
        String functionName = syntax.getFirstChild().getText();
		FormalParameter[] costParms = FormalParameter.buildFormals(config.iNodeClass, config.reducerNodeName);

        StringTemplate costFunction = defineMethod(Modifier.PRIVATE, "int", functionName, costParms, throwsNothing );
        addContents(costFunction, getCodeBlock(syntax));
        return costFunction;
	}

    /**
     * Emit the label(ast) function.
     */
	public void emitLabelFunction(PrintStream output)
	{
        Object setAnnotation = config.annotationAccessor != null?
                codeEmitter.genCallMethod(
                    config.initialParamName,
                    "setAnnotation", 
                    codeEmitter.genCast(config.annotationAccessor.setParameterType, "result")
                ):
                null;

		output.println(getTemplate(
            "labelFunction",
            "getArity",         new GetArity(config.initialParamName),
            "getNthChild",      new GetNthChild(config.initialParamName, "i"),
            "setAnnotation",    setAnnotation
        ));
	}

    /**
     *  Emit the subclasses of JBurgAnnotation that encode data for specific pattern matches,
     *  and getJBurgAnnotation(inode), the routine that assigns an annotation to each inode.
     *  @param output - the destination output stream.
     */
    void emitAnnotations(PrintStream output)
    {
        Set<String> allOperators = annotationsByEquivalenceClass.getOperators();

        //  Emit an annotation object for each equivalence class of rules.
        for ( String operator: allOperators )
            for ( AnnotationSemantics currentAnnotation : annotationsByEquivalenceClass.getAnnotationSemantics(operator))
                emitAnnotation(output, operator, currentAnnotation);

        //  Emit getJBurgAnnotation
        StringTemplate getJBurgAnnotation = defineMethod(
            Modifier.PUBLIC,
            config.options.annotationInterfaceName,
            "getJBurgAnnotation",
            FormalParameter.buildFormals(config.iNodeClass, "node"),
            throwsNothing
        );

        // A code fragment that fetches the node's actual arity.
        Object actualArity = new GetArity("node");
        Object actualOpcode = new GetOperator("node");

        StringTemplate switchOnNode = addSubTemplate(
            getJBurgAnnotation,
            "switch",
            "expr", actualOpcode
        );

        for ( String operator: allOperators ) {


            List<AnnotationSemantics> annotations = annotationsByEquivalenceClass.getAnnotationSemantics(operator);

            // Checking the subtree's arity is a tautology if the only
            // annotation holds 0..N children.
            if (annotations.size() == 1 && annotations.get(0).holdsZeroToN()) {

                StringTemplate opCase = addSubTemplate(switchOnNode, "switchCaseNoFallthrough", "label", operator);
                // In this case, we know this cannot be a singleton.
                Object annotation = getTemplate(
                    "newObject",
                    "type", annotations.get(0).getSpecializedClassName(),
                    "parameters", "this, node"
                );
                addSubTemplate(opCase, "returnStmt", "value", annotation);

            } else {

                StringTemplate opCase = addSubTemplate(switchOnNode, "switchCase", "label", operator);

                for ( AnnotationSemantics annotationSemantics : annotations) {

                    Object annotation;
                    
                    if (config.annotationAccessor != null && annotationSemantics.canBeSingleton()) {
                        annotation = getTemplate(
                            "singletonInstance",
                            "singletonClass", annotationSemantics.getSpecializedClassName()
                        );
                    } else {
                        annotation = getTemplate(
                            "newObject",
                            "type", annotationSemantics.getSpecializedClassName(),
                            "parameters", "this, node"
                        );
                    }

                    int arity = annotationSemantics.getMinimumArity();

                    StringTemplate ifStmt = addSubTemplate(
                        opCase,
                        "ifThen",
                        "condition",
                            annotationSemantics.hasFixedArity()?
                                getTemplate("equals", "lhs", actualArity, "rhs", arity):
                                getTemplate("greaterThanOrEquals", "lhs", actualArity, "rhs", arity),
                        "contents", getTemplate("returnStmt", "value", annotation)
                    );
                }
            }
        }

        // Fall through and return the placeholder annotation.
        StringTemplate switchDefault = addSubTemplate(switchOnNode, "switchDefault");

        addSubTemplate(
            getJBurgAnnotation,
            "returnStmt",
            "value", codeEmitter.genNewObject( "PlaceholderAnnotation", "this", "node", actualArity)
        );

        output.println(getJBurgAnnotation);
    }

    /**
     *  Emit an annotation subclass.
     *  @param output - the output stream.
     *  @param semantics - semantic information related to this subclass.
     */
    void emitAnnotation(PrintStream output, String operator, AnnotationSemantics semantics)
    {
        List<JBurgRule> currentRules = semantics.getRules();
        int nominalArity = semantics.getMinimumArity();

        // Closure cost graph.
        ClosureGraph closureCosts = semantics.getClosureGraph();

        // Pattern-matching rules by nonterminal.
        AnnotationSemantics.ProductionMap patternMatches = semantics.getPatternMatches();
 
        //  Pattern-matching rules and closures by nonterminal.
        AnnotationSemantics.ProductionMap productions = semantics.getAllProductions();

        //  Does the annotation have fixed arity?
        boolean fixedArity = semantics.hasFixedArity();

        // Find common subtree paths and cache them.
        // Emitting these variable declarations mutates the 
        // pattern matchers, so they can only be emitted once.
        // Capture the results so we can write it more than once.
        Map<JBurgPatternMatcher,String> factored_variables = semantics.getFactoredPathVariables();

        /*
         * Begin code-gen of the class.
         */
        output.println();
        String annotationClassName = semantics.getSpecializedClassName();
        StringTemplate annotationClass = getTemplate(
            "innerClass",
            "className", annotationClassName,
            "baseClassName", "JBurgSpecializedAnnotation"
        );

        //  Emit caches for any costs that require a function call;
        //  the BURM's contract says these functions are only called once.
        Set<String> emittedCosts = new HashSet<String>();

        for ( List<ClosureRecord> closures: closureCosts.values() )
            for ( ClosureRecord closure: closures )
                if ( closure.costComputedViaFunction() && emittedCosts.add(closure.getCachedCost()) )
                    addCachedCost(annotationClass, closure.getCachedCost(), closure.getCost("m_node")); 

        for ( JBurgRule rule: currentRules ) {

            if ( rule.needsExplicitCostCheck() && rule.isStableCostFunction() )
                addGetCostForRule(annotationClass, semantics, rule, "this");

            if ( rule.costComputedViaFunction() && rule.isStableCostFunction() && emittedCosts.add(rule.getCachedCost()) )
                addCachedCost(annotationClass, rule.getCachedCost(), rule.getCost("m_node")); 
        }

        this.codeEmitter.setDefaultAttribute("annotationClass", annotationClassName);
        
        //  Emit a field for each child.
        for ( int fieldIdx = 0; fieldIdx < nominalArity; fieldIdx++ ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField(
                    Modifier.PUBLIC,
                    config.options.annotationInterfaceName,
                    String.format("subtree%d", fieldIdx),
                    codeEmitter.genNullPointer()
                )
            );
        }

        for ( String cachedCostVar: semantics.getCachedCosts().values() ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField( Modifier.PRIVATE, "int", cachedCostVar, UNINITIALIZED)
            );
        }

        if ( !fixedArity ) {

            addContents(
                annotationClass,
                codeEmitter.genInstanceField( 
                    Modifier.PUBLIC,
                    codeEmitter.genNaryContainerType(config.options.annotationInterfaceName),
                    "narySubtrees",
                    codeEmitter.defineContainer(config.options.annotationInterfaceName)
                )
            );
        }

        // Emit the constructor.
        assert(config.options.className != null);
        StringTemplate constructor = codeEmitter.getConstructorBody(
            codeEmitter.declareMethod(
                Modifier.PUBLIC,
                "",
                annotationClassName,
                FormalParameter.buildFormals(
                    codeEmitter.getReferenceType(config.options.className), "burm",
                    config.iNodeClass, "node"
                ),
                throwsNothing
            ),
            "JBurgSpecializedAnnotation",
            "burm","node"
        );
        addContents(annotationClass, constructor);

        /* getPatternMatchCost(nonterminal) */
        if ( patternMatches.keySet().size() > 0 ) {

            StringTemplate getPatternMatchCost = addMethod(
                annotationClass,
                Modifier.PRIVATE,
                "int",
                "getPatternMatchCost",
                FormalParameter.buildFormals(config.ntType, "goalState"),
                throwsNothing
            );
            emitGetPatternMatchCost(getPatternMatchCost, semantics);

        }

        ArrayList<String> closureCaches = new ArrayList<String>();

        /* getClosureCost(nonterminal) */
        if ( closureCosts.keySet().size() > 0 ) {

            StringTemplate getClosureCost = addMethod(
                annotationClass,
                Modifier.PRIVATE,
                "int",
                "getClosureCost",
                FormalParameter.buildFormals(config.ntType, "goalState"),
                throwsNothing
            );
            emitGetClosureCost(getClosureCost, semantics, closureCosts, closureCaches);
        }

        for ( String closureCacheVar: closureCaches ) {

            addContents(annotationClass, codeEmitter.genInstanceField(Modifier.PRIVATE, "int", closureCacheVar, UNINITIALIZED));
        }

        /* getCost(nonterminal) */
        StringTemplate getCost = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            "int",
            "getCost",
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );
        emitGetCost(getCost, semantics, "this");

        /* getRule(nonterminal) */
        StringTemplate getRule = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            "int",
            "getRule",
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );
        emitGetRule(getRule, semantics);

        /* getArity() */
        StringTemplate getArity = addMethod(
            annotationClass, 
            Modifier.PUBLIC,
            "int",
            "getArity",
            noFormalParameters,
            throwsNothing
        );

        if ( fixedArity ) {
            addReturnValue(getArity, Integer.toString(nominalArity));
        } else {

            StringTemplate narySize = getTemplate("narySubtreeSize", "stem", "narySubtrees");

            if ( nominalArity != 0 ) {
                addReturnValue(getArity, codeEmitter.genCast("int", getTemplate("add", "lhs", nominalArity, "rhs", narySize)));
            } else {
                addReturnValue(getArity, codeEmitter.genCast("int", narySize));
            }
        }


        /*
         *  **  Emit overrides for getNthChild() and addChild() if the annotation has subtrees  **
         */
        if ( nominalArity > 0 || !fixedArity ) {

            //  getNthChild
            StringTemplate getNthChild = addMethod(
                annotationClass,
                Modifier.PUBLIC,
                config.options.annotationInterfaceName,
                "getNthChild",
                FormalParameter.buildFormals("int", "index"),
                throwsNothing
            );

            addVariableDecl(getNthChild, codeEmitter.getAnnotationType(), "result", getTemplate("nullPointer"));
            StringTemplate switchOnIndex = addSubTemplate(getNthChild, "switch", "expr", "index");

            for ( int i = 0; i < nominalArity; i++ ) {

                StringTemplate switchCase = addSubTemplate(switchOnIndex, "switchCase", "label", new Integer(i));
                addAssignment(switchCase, "result", String.format("subtree%d", i));
            }

            if ( ! fixedArity ) {

                StringTemplate switchDefault = addSubTemplate(switchOnIndex, "switchDefault");
                if ( nominalArity == 0 ) {

                    addSubTemplate(switchDefault,
                        "assign",
                        "lvar", "result",
                        "rvalue", getTemplate("narySubtreeGet", "stem", "narySubtrees", "index", "index")
                    );
                } else {

                    addSubTemplate(switchDefault,
                        "assign",
                        "lvar", "result",
                        "rvalue", getTemplate(
                            "narySubtreeGet",
                            "stem", "narySubtrees",
                            "index", getTemplate("subtract", "lhs", "index", "rhs", new Integer(nominalArity))
                        )
                    );
                }
            } else {

                StringTemplate switchDefault = addSubTemplate(switchOnIndex, "switchDefaultNoFallthrough");
                addThrow(switchDefault, codeEmitter.getStringIntConcat("\"Invalid index \"", "index"));
            }

            addReturnValue(getNthChild, "result");

            /*  addChild */
            StringTemplate addChild = addMethod(
                annotationClass,
                Modifier.PUBLIC,
                "void",
                "addChild",
                FormalParameter.buildFormals(config.options.annotationInterfaceName, "child"),
                throwsNothing
            );

            // We're going to compose a sequence
            // of operations, each extending the
            // previous operation.
            StringTemplate previousOp = addChild;

            if ( nominalArity > 0 ) {

                for ( int i = 0; i < nominalArity; i++ ) {

                    Object currentChild = String.format("subtree%d", i);
                    StringTemplate isNull = getTemplate("isNull", "expr", currentChild);

                    if ( i == 0 ) {

                        StringTemplate ifThen = getTemplate("ifThen", "condition", isNull);
                        addContents(previousOp, ifThen);
                        previousOp = ifThen;
                    } else {

                        StringTemplate elseif = getTemplate("ifElseArm", "condition", isNull);
                        previousOp.setAttribute("elseArm", elseif);
                        previousOp = elseif;
                    }
                    addAssignment(previousOp, currentChild, "child");
                }

                StringTemplate finalElse = getTemplate("ifElseArm");
                previousOp.setAttribute("elseArm", finalElse);
                previousOp = finalElse;
            }

            if ( ! fixedArity ) {
                addExprStatement(previousOp, codeEmitter.getAddChild());
            } else {
                addThrow(previousOp, "\"too many children\"");
            }
        }

        /* getOperator() and getSelfDescription() */
        StringTemplate getOperator = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            config.opcodeType,
            "getOperator",
            noFormalParameters,
            throwsNothing
        );

        addReturnValue(getOperator, operator);

        StringTemplate getSelfDescription = addMethod(
            annotationClass,
            Modifier.PUBLIC,
            codeEmitter.getStringClassName(),
            "getSelfDescription",
            noFormalParameters,
            throwsNothing
        );

        // FIXME: Need a genStringConstant routine.
        addReturnValue(getSelfDescription, "\"" + annotationClassName + "\"");

        //  Write out the compressed annotation's class declaration.
        output.println(annotationClass);

        // Reset the class name to default.
        this.codeEmitter.setDefaultAttribute("annotationClass", null);
    }

    private void emitGetCost(StringTemplate getCost, AnnotationSemantics semantics, String objectRef)
    {
        ClosureGraph closureCosts = semantics.getClosureGraph();
        AnnotationSemantics.ProductionMap patternMatches = semantics.getPatternMatches();

        addVariableDecl(getCost, "int", "result", codeEmitter.genMaxIntValue());

        StringTemplate switchOnGoal = getTemplate("switch", "expr", "goalState");
        addContents(getCost, switchOnGoal);

        for ( String nonterminal: semantics.getAllGoalStates() ) {

            StringTemplate switchCase = addSubTemplate(
                switchOnGoal, 
                "switchCase",
                "label", getUndecoratedNonterminal(nonterminal)
            );

            Object cost;
            
            if (nonterminal.equals(config.wildcardState)) {
                cost = "1";
            } else {
                cost = semantics.findOptimalCost(nonterminal);
            }

            StringTemplate callGetPatternMatchCost = getTemplate(
                "callMethod",
                "nameElements", new String[] {objectRef, "getPatternMatchCost"},
                "params", getNonterminal(nonterminal)
            );

            StringTemplate callGetClosureCost = getTemplate(
                "callMethod",
                "nameElements", new String[] {objectRef, "getClosureCost"},
                "params", getNonterminal(nonterminal)
            );

            if (cost != null) {
                // Cost is known at compiler-compile time and
                // its value is in the cost variable; carry on
                // and emit it.
            } else if ( closureCosts.containsKey(nonterminal) && patternMatches.containsKey(nonterminal) ) {
                cost = genMinimum(callGetPatternMatchCost, callGetClosureCost);
            } else if ( patternMatches.containsKey(nonterminal) ) {
                cost = callGetPatternMatchCost;
            } else if ( closureCosts.containsKey(nonterminal) ) {
                cost = callGetClosureCost;
            } else {
                throw new IllegalStateException("Internal error: No closure or pattern cost for " + nonterminal);
            }

            if ( semantics.getCachedCosts().containsKey(nonterminal) ) {

                String cachedCostVar = semantics.getCachedCosts().get(nonterminal);
                // Put the cost into the cache if it's not already done.
                StringTemplate checkCache = addSubTemplate(
                    switchCase,
                    "ifThen",
                    "condition", getTemplate(
                        "equals",
                        "lhs", genMemberAccess(objectRef, cachedCostVar),
                        "rhs", UNINITIALIZED
                    )
                );

                addAssignment(checkCache, genMemberAccess(objectRef, cachedCostVar), cost);
                addAssignment(switchCase, "result", genMemberAccess(objectRef, cachedCostVar));

            } else {
                addAssignment(switchCase, "result", cost);
            }
        }

        addReturnValue(getCost, "result");
    }

    private void emitGetPatternMatchCost(StringTemplate getPatternMatchCost, AnnotationSemantics semantics)
    {
        AnnotationSemantics.ProductionMap patternMatches = semantics.getPatternMatches();
        AnnotationSemantics.ProductionMap productions = semantics.getAllProductions();

        addVariableDecl(getPatternMatchCost, "int", "result", codeEmitter.genMaxIntValue());

        StringTemplate switchOnGoal = addSubTemplate(getPatternMatchCost, "switch", "expr", "goalState");

        for ( String nonterminal: patternMatches.keySet() ) {

            List<JBurgProduction> currentPatterns = patternMatches.get(nonterminal);

            StringTemplate switchCase = getTemplate("switchCase", "label", getUndecoratedNonterminal(nonterminal));
            addContents(switchOnGoal, switchCase);

            addAssignment(switchCase, "result", getCostForProduction(currentPatterns.get(0), productions));

            for ( int i = 1; i < currentPatterns.size(); i++ )
                addAssignment(switchCase, "result", genMinimum("result", getCostForProduction(currentPatterns.get(i), productions)));
        }
        addReturnValue(getPatternMatchCost, "result");
    }


    private void emitGetClosureCost(StringTemplate getClosureCost, AnnotationSemantics semantics, ClosureGraph closureCosts, List<String> closureCaches)
    {
        AnnotationSemantics.ProductionMap patternMatches = semantics.getPatternMatches();
        AnnotationSemantics.ProductionMap productions = semantics.getAllProductions();

        addVariableDecl(getClosureCost, "int", "result", codeEmitter.genMaxIntValue());

        StringTemplate switchOnGoal = getTemplate("switch", "expr", "goalState");
        addContents(getClosureCost, switchOnGoal);
            
        for ( String nonterminal : closureCosts.keySet() ) {

            StringTemplate switchCase = getTemplate("switchCase", "label", getUndecoratedNonterminal(nonterminal));
            addContents(switchOnGoal, switchCase);

            Set<String> doneNts = new HashSet<String>();
            List<String> closureComputations = new ArrayList<String>();

            for ( ClosureRecord closure: closureCosts.get(nonterminal) )
                closureComputations.addAll(getAntecedentCosts(closure, doneNts, closureCosts, patternMatches));

            if ( doneNts.contains(nonterminal) )
                config.logger.error(String.format("cyclical closure from %s to %s", nonterminal, nonterminal));

            // Don't emit pattern match costs for the final level;
            // they're redundant with the computation in getCost().
            closureComputations.add(getClosureCostComputation(nonterminal, closureCosts, patternMatches, false));

            boolean cacheClosure = closureComputations.size() > config.closureCacheThreshold;
            String closureCacheVar = String.format("cachedClosure_%x", System.identityHashCode(closureComputations));

            StringTemplate closureContainer = switchCase;

            if ( cacheClosure ) {

                closureCaches.add(closureCacheVar);
                closureContainer = getTemplate(
                    "ifThen",
                    "condition", getTemplate("equals", "lhs", closureCacheVar, "rhs", UNINITIALIZED)
                );
                addContents(switchCase, closureContainer);
            }

            for ( String s: closureComputations )
                addContents(closureContainer, s);

            if ( cacheClosure ) {

                addAssignment(closureContainer, closureCacheVar, String.format("cost_%s", nonterminal));
                addAssignment(switchCase, "result", closureCacheVar);

            } else {
                addAssignment(switchCase, "result", String.format("cost_%s", nonterminal));
            }
        }

        addReturnValue(getClosureCost, "result");
    }

    private void emitGetRule(StringTemplate getRule, AnnotationSemantics semantics)
    {

        addVariableDecl(getRule, "int", "rule", NO_FEASIBLE_RULE);
        StringTemplate switchOnGoal = addSubTemplate(
            getRule,
            "switch",
            "expr", "goalState"
        );

        AnnotationSemantics.ProductionMap productions = semantics.getAllProductions();
        boolean allRulesConstant = true;

        for ( Map.Entry<String, List<JBurgProduction>> productionsByNonterminal: productions.entrySet() ) {

            String nonterminal = productionsByNonterminal.getKey();

            StringTemplate switchCase = addSubTemplate(
                switchOnGoal,
                "switchCase",
                "label", getUndecoratedNonterminal(nonterminal)
            );

            /*
             * Try to resolve the optimal production at compiler-compile time.
             */
            JBurgProduction optimalProduction = semantics.findOptimalProduction(nonterminal);

            if ( optimalProduction != null ) {
                addAssignment(switchCase, "rule", Integer.toString(optimalProduction.getReduceAction().getIndex()));
            } else {

                allRulesConstant = false;

                /*
                 * Emit the analogous compile-time computation.
                 */
                List<JBurgProduction> currentProductions = productionsByNonterminal.getValue();

                int nProductions = currentProductions.size();

                //  Emit this declaration at its first use.
                boolean currentCostDeclared = false;

                // Cache the best cost so far if necessary.
                Object bestKnownCost;

                if ( nProductions > 1 ) {
                    addVariableDecl(switchCase, "int", "bestCost", codeEmitter.genMaxIntValue());
                    bestKnownCost = "bestCost";
                } else {
                    bestKnownCost = codeEmitter.genMaxIntValue();
                }

                if (nProductions == 1) {
                    JBurgProduction production = currentProductions.get(0);

                    if (production.computesConstantCost(productions)) {
                        // Rule selected at compiler-compile time.
                        addReturnValue(switchCase, production.getReduceAction().getIndex());
                    } else {
                        // We have to test the cost before returning the rule.
                        StringTemplate testOnlyRule = addSubTemplate(
                            switchCase,
                            "ifThen",
                            "condition", codeEmitter.genCmpLess(
                                bestKnownCost.toString(),
                                codeEmitter.genCallMethod(null, "getCost", getNonterminal(nonterminal))
                            )
                        );
                        addReturnValue(testOnlyRule, production.getReduceAction().getIndex());
                    }

                } else {
                    for ( int i = 0; i < nProductions; i++ ) {

                        //  Extract required information from the production:
                        //  what is its cost, and is it constant?
                        JBurgProduction production = currentProductions.get(i);
                        Object          currentProductionCost;
                        boolean         costIsConstant = production.computesConstantCost(productions);

                        if (costIsConstant) {
                            int constantCost = production.getConstantCost(productions);

                            // Don't bother testing unfeasible rules.
                            if (constantCost == Integer.MAX_VALUE) {
                                continue;
                            }

                            currentProductionCost = Integer.toString(constantCost);
                        } else {
                            currentProductionCost = getCostForProduction(production, productions);
                        }

                        //  Generate the necessary tests and assignments.

                        //  If the first production's cost is constant,
                        //  testing it against bestCost is a tautology.
                        boolean needComparison = !costIsConstant || (i > 0);

                        StringTemplate costContainer = switchCase;

                        if ( needComparison ) {

                            //  If the cost uses a computation, put it in a temp.
                            if ( !costIsConstant ) {

                                if ( currentCostDeclared ) {
                                    addAssignment(switchCase, "currentCost", currentProductionCost);
                                    currentProductionCost = "currentCost";

                                } else if (nProductions > 1) {

                                    addVariableDecl(switchCase, "int", "currentCost", currentProductionCost);
                                    currentCostDeclared = true;
                                    currentProductionCost = "currentCost";
                                }
                                // else fall through using the cost in-line for the comparison.
                            }

                            costContainer = addSubTemplate(
                                costContainer,
                                "ifThen",
                                "condition", codeEmitter.genCmpLess(bestKnownCost.toString(), currentProductionCost)
                            );
                        }

                        //  Track the new best cost if there's another choice to be evaluated.
                        if ( i + 1 < currentProductions.size() )
                            addAssignment(costContainer, bestKnownCost, currentProductionCost);

                        addAssignment(costContainer, "rule", production.getReduceAction().getIndex());
                    }
                }
            }
        }

        addReturnValue(getRule, "rule");
    }

    /**
     *  @return the expression to use for a production's cost;
     *    this may be an arithmetic expression or a call
     *    to an implementation method, depending on
     *    the production's complexity.
     */
    Object getCostForProduction(JBurgProduction production, AnnotationSemantics.ProductionMap productions)
    {
        if ( production instanceof JBurgRule ) {
            JBurgRule rule = (JBurgRule) production;

            if ( rule.needsExplicitCostCheck() ) {
                if ( rule.isStableCostFunction() )
                    return this.codeEmitter.genCallMethod(null, getCostingFunctionForRule(rule), "goalState");
                else
                    return rule.getCost("getNode()");
            } else {
                return getSumOfRuleCosts(rule);
            }
        } else {
            assert production instanceof ClosureRecord;
            return ((ClosureRecord)production).getCostComputation(productions);
        }
    }

    /**
     *  Emit a rule's cost function.
     *  @param output - the current output stream.
     *  @param semantics - the semantic information about the current annotation class.
     *  @param rule - the rule to emit.
     *  @param objectRef - the path to the object.
     */
    void addGetCostForRule(StringTemplate container, AnnotationSemantics semantics, JBurgRule rule, String objectRef)
    {
        assert(rule.needsExplicitCostCheck());

        StringTemplate method = addMethod(
            container,
            Modifier.PRIVATE,
            "int",
            getCostingFunctionForRule(rule),
            FormalParameter.buildFormals(config.ntType, "goalState"),
            throwsNothing
        );

        for (String var_decl: semantics.getFactoredPathVariables().values())
            if (rule.patternMatcher.usesFactoredVariable(var_decl))
                addContents(method, var_decl);

        Object patternMatch = rule.patternMatcher.generatePatternRecognizer(
                codeEmitter,
                objectRef
            );

        // The pattern match may be null if it's trival.
        StringTemplate matcher;

        if ( patternMatch != null ) {

            matcher = addSubTemplate(
                method,
                "ifThen",
                "condition", patternMatch
            );

            StringTemplate failedMatch = getTemplate("ifElseArm");
            addReturnValue(failedMatch, codeEmitter.genMaxIntValue());
            matcher.setAttribute("elseArm", failedMatch);

        } else {
            matcher = method;
        }

        // Cache this cost if necessary.
        String nonterminal = rule.getGoalState();

        if ( semantics.getCachedCosts().containsKey(nonterminal) ) {
            String cachedCostVar = semantics.getCachedCosts().get(nonterminal);

            // Put the cost into the cache if it's not already done.
            StringTemplate checkCache = addSubTemplate(
                matcher,
                "ifThen",
                "condition", getTemplate(
                    "equals",
                    "lhs", genMemberAccess(objectRef, cachedCostVar),
                    "rhs", UNINITIALIZED
                )
            );

            addAssignment(checkCache, genMemberAccess(objectRef, cachedCostVar), getSumOfRuleCosts(rule));
            addReturnValue(matcher, cachedCostVar);
        } else {
            addReturnValue(matcher, getSumOfRuleCosts(rule));
        }
    }

    /**
     *  @return a unique identifier for the method that computes
     *    a rule's cost (note: this is not the rule's cost function).
     */
    String getCostingFunctionForRule(JBurgRule rule)
    {
        return String.format("getCostFor%s", rule.getUniqueId());
    }

    /**
     *  Emit the cache field and accessor function for
     *  the cached result of a cost function call.
     */
    void addCachedCost(StringTemplate container, String functionName, String payload)
    {
        //  Strip () characters.
        functionName = functionName.substring(0, functionName.length() -2);

        String varName = String.format("cachedCostFunctionResult_%h", functionName);

        addContents(container, codeEmitter.genInstanceField( Modifier.PRIVATE, "int", varName, UNINITIALIZED));

        StringTemplate method = addMethod(
            container,
            Modifier.PRIVATE,
            "int",
            functionName,
            noFormalParameters,
            throwsNothing
        );

        StringTemplate testInit = addSubTemplate(
            method,
            "ifThen",
            "condition", codeEmitter.genCmpEquality(varName, UNINITIALIZED, true)
        );
        addAssignment(testInit, varName, payload);
        addReturnValue(method, varName);
    }

    /**
     *  Add up all of a rule's cost factors.
     *  @param rule - the rule of interest.
     *  @return an overflow-safe addition of the
     *    rule's cost and the costs of its subtrees.
     */
    Object getSumOfRuleCosts(JBurgRule rule)
    {
        Object subtreeCost = null;

        for ( JBurgPatternMatcher subgoal: rule.patternMatcher.getParameterizedSubtrees() ) {
            Object subgoalCost = subgoal.generateCost(codeEmitter, "this");

            if ( subgoalCost != null )
                subtreeCost = codeEmitter.genOverflowSafeAdd(subtreeCost, subgoalCost);
        }

        if ( subtreeCost != null ) {
            return codeEmitter.genOverflowSafeAdd(rule.getCachedCost("getNode()"), subtreeCost);
        } else {
            return rule.getCachedCost();
        }
    }


    StringTemplate defineMethod(int modifiers, Object returnType, Object name, FormalParameter[] formalParameters, Class<?>[] exceptions )
    {
        return getTemplate(
            "method",
            "decl", codeEmitter.declareMethod (
                modifiers,
                returnType,
                name,
                formalParameters,
                exceptions
            )
        );
    }

    /**
     * Add a local variable to a container template.
     * @param container     the containing template.
     * @param varType       the variable's type.
     * @param varName       the variable's name.
     * @param initializer   the variable's initializer, or null.
     */
    void addLocalVar(StringTemplate container, Object varType, Object varName, Object initializer)
    {
        addContents(container, codeEmitter.genLocalVar(varType, varName, initializer));
    }

    /**
     *  Convenience method wraps codeEmitter.genGetGoalState.
     */
    Object getNonterminal(String raw_nt)
    {
        return codeEmitter.genGetGoalState(raw_nt);
    }

    /**
     *  Convenience method wraps codeEmitter.genGetUndecoratedGoalState.
     */
    Object getUndecoratedNonterminal(String raw_nt)
    {
        return codeEmitter.genGetUndecoratedGoalState(raw_nt);
    }

    /**
     *  @return the input string with its outer
     *    layer of {} brackets stripped off.
     */
    public static String stripBrackets(String src)
    {
        int startchar = src.indexOf('{') + 1;
        int lentoend = src.lastIndexOf('}');
        return src.substring( startchar, lentoend-startchar );
    
    }

    /**
     *  Generate the calling sequence for the label() method.
     */
    Object genCallLabel(Object indexTerm)
    {
        return this.codeEmitter.genCallMethod(
            "this",
            "label",
            codeEmitter.genCast( 
                config.iNodeClass, 
                new GetNthChild(config.initialParamName, indexTerm)
            )
        );
    }

    /**
     * Generate code to check for a minumum of two values.
     * @param lhs the left-hand expression.
     * @param rhs the right-hand expression.
     * @return platform-specific code to get the minimum of these values.
     */
    Object genMinimum(Object lhs, Object rhs)
    {
        if ( lhs.equals(rhs) && config.volatileCostFunctions.size() == 0 )
            return lhs.toString();
        else
            return getTemplate("minimumOf", "e1", lhs, "e2", rhs);
    }

    /**
     * Translate a JBurg platform-neutral expression
     * into platform-specific code.
     */
    Object emitExpression(AST expr)
    {
        ExpressionParser parser = new ExpressionParser();
        parser.setCodeEmitter(this.codeEmitter);

        try {
            parser.burm(expr);
        }
        catch ( Exception burmProblem ) {

            config.logger.exception(String.format("translating %s", expr), burmProblem);
        }

        return parser.getResult();
    }

    /**
     * Get the cost of a closure as a "term" of a closure cost function.
     * @param nonterminal the goal nonterminal.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @param emitPatternMatch if set, emit a pattern match if the nonterminal
     * has any pattern matches; true when emitting antecedent terms, false
     * when emitting the final term, when the computation would be redundant
     * with the computation in getCost().
     * @return the closure's cost, expressed as an initialization of a cost term.
     */
    String getClosureCostComputation(String nonterminal, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches, boolean emitPatternMatch)
    {
        Object minCost;
        String patternMatchCost = this.codeEmitter.genCallMethod("this", "getPatternMatchCost", getNonterminal(nonterminal)).toString();

        //  Determine the minimum cost.
        if ( closureCosts.containsKey(nonterminal) ) {

            List<ClosureRecord> possibleClosures = closureCosts.getSet(nonterminal);

            minCost = getClosureCost(possibleClosures.get(0), closureCosts, patternMatches);

            for ( int i = 1; i < possibleClosures.size(); i++ ) {
                minCost = genMinimum(minCost, getClosureCost(possibleClosures.get(i), closureCosts, patternMatches));
            }

            if ( patternMatches.containsKey(nonterminal) && emitPatternMatch ) {
                minCost = genMinimum(minCost, patternMatchCost);
            }

        } else {
            minCost = patternMatchCost;
        }

        return getTemplate(
            "declareLocalVariable",
            "type", "int",
            "name", String.format("cost_%s", nonterminal), 
            "initializer", minCost
        ).toString();
    }

    /**
     * Get the cost of a closure with its antecedent "term."
     * @param closure the closure of interest.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return the closure's cost as an expression usable within the annotation class' instance methods.
     */
    String getClosureCost(ClosureRecord closure, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches)
    {
        return closure.getCostComputation("getNode()", "cost_" + getNonTrivialAntecedent(closure.getAntecedentState(), closureCosts, patternMatches));
    }

    /**
     * Get all the antecedent costs for a closure.
     * @param closure the closure of interest.
     * @param doneNts antecedents already recorded; mutated to record
     * the current closure, if it hasn't already been emitted.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return a list of all the antecedent "terms" in the closure cost.
     */
    List<String> getAntecedentCosts(ClosureRecord closure, Set<String> doneNts, ClosureGraph closureCosts, AnnotationSemantics.ProductionMap patternMatches)
    {
        List<String> result = new ArrayList<String>();

        // Look past any trivial antecedents; if foo = bar is the only antecedent
        // reduction, and it has zero cost, and bar itself has an antecedent, then
        // we're interested in the value of bar.
        // TODO: Also elide the corresponding reduction.
        String antecedent = getNonTrivialAntecedent(closure.getAntecedentState(), closureCosts, patternMatches); 

        if ( doneNts.add(antecedent) )
        {
            if ( closureCosts.containsKey(antecedent) )
                for ( ClosureRecord antecedentClosure: closureCosts.get(antecedent) )
                    result.addAll(getAntecedentCosts(antecedentClosure, doneNts, closureCosts, patternMatches));

            result.add(getClosureCostComputation(antecedent, closureCosts, patternMatches, true));
        }

        return result;
    }

    /**
     * Look through any trivial antecedent states; a trivial
     * antecedent has a single, zero-cost closure and no pattern match.
     * @param antecedent the nonterminal state of interest.
     * @param closureCosts the current annotation's graph of closure costs.
     * @param patternMatches the current annotation's pattern matches.
     * @return the first non-trivial antecedent found.
     */
    String getNonTrivialAntecedent(String antecedent, ClosureGraph closureGraph, AnnotationSemantics.ProductionMap patternMatches)
    {
        // If this antecedent state has its own antecedent:
        if (closureGraph.containsKey(antecedent) && !patternMatches.containsKey(antecedent))
        {
            List<ClosureRecord> closures = closureGraph.get(antecedent);
            if ( closures.size() == 1 && closures.get(0).costIsZero() ) {
                // One closure with zero cost: trivial, look through it.
                return getNonTrivialAntecedent(closures.get(0).getAntecedentState(), closureGraph, patternMatches);
            }
        }

        // This is a non-trival closure.
        return antecedent;
    }

    /**
     * Select a template by name, with optional attributes.
     * @param name the template's name.
     * @param attrValue pairs of attrName, attrValue.
     */
    private StringTemplate getTemplate(String name, Object ... attrValue)
    {
        return this.codeEmitter.getTemplate(name, attrValue);
    }

    private StringTemplate addSubTemplate(StringTemplate container, String name, Object ... attrValue)
    {
        StringTemplate contents = getTemplate(name, attrValue);
        addContents(container, contents);
        return contents;
    }

    /**
     * Add a variable declaration to a container's template.
     * @param container the container's template.
     * @param type the variable's type.
     * @param name the variable's name.
     * @param initialValue the variable's initial value, or null.
     */
    private void addVariableDecl(StringTemplate container, Object type, Object name, Object initialValue)
    {
        addFieldOrVariableDecl(container, "declareLocalVariable", type, name, initialValue);
    }

    private void addFieldOrVariableDecl(StringTemplate container, String template,  Object type, Object name, Object initialValue)
    {
        addContents(
            container,
            getTemplate(
                template,
                "type", type,
                "name", name,
                "initializer", initialValue
            )
        );
    }

    /**
     * Add an assignment statement to a container template.
     * @param method the method's template.
     * @param lvalue the receiving lvalue.
     * @param rvalue the value to assign.
     */
    private void addAssignment(StringTemplate method, Object lvalue, Object rvalue)
    {
        addContents(method, getTemplate( "assign", "lvar", lvalue, "rvalue", rvalue));
    }

    /**
     * Add contents to a container template.
     * @param container  the container.
     * @param contents the contents.
     */
    private void addContents(StringTemplate container, Object contents)
    {
        container.setAttribute("contents", contents);
    }

    /**
     * Add a return statement to a container template.
     * @param container the containing template.
     * @param value the value to return.
     */
    private void addReturnValue(StringTemplate container, Object value)
    {
        addContents(container, getTemplate( "returnStmt", "value", value));
    }

    /**
     * Add an expression statement to a container template.
     * @param container the containing template.
     * @param expr the expression to add as a statement-level construct.
     */
    private void addExprStatement(StringTemplate container, Object expr)
    {
        addContents(container, getTemplate("statement", "expr", expr));
    }

    /**
     * Add a throw statement to a container template.
     * @param container the containing template.
     * @param diagnostic an expression that generates a diagnostic.
     */
    private void addThrow(StringTemplate container, Object diagnostic)
    {
        addExprStatement(container, getTemplate("throwDiagnostic", "diagnostic", diagnostic));
    }

    private StringTemplate addMethod(StringTemplate container, int modifiers, Object returnClass, Object name, FormalParameter[] formals, Class[] exceptions)
    {
        StringTemplate result = defineMethod(modifiers, returnClass, name, formals, exceptions);
        addContents(container, result);
        return result;
    }

    /**
     * @return this generator's code emitter.
     */
    public EmitLang getCodeEmitter()
    {
        return this.codeEmitter;
    }

    public Object getReducerNodeType()
    {
        return config.iNodeClass;
    }

    public StringTemplate genMemberAccess(Object stem, Object member)
    {
        return getTemplate("memberAccess", "stem", stem, "member", member);
    }
}
