<h2>JBurg Users' Guide</h2>

<p><a href="#installing">Installing JBurg</a>
<p><a href="#running">Generating a BURM with JBurg</a>
<p><a href="#integration">Integrating the generated BURM into your compiler</a>
<p><a href="#debugging">Debugging the BURM</a>
<dir><a href="#unmatchedRule">Unable to find a rule to process x(22){-1}</a></dir>
<p><a href="#modifying">Notes on modifying JBurg</a>
<p><a href="#rebuilding">Rebuilding JBurg</a>
<hr>

<br><a name="installing"/>
<h3>Installing JBurg</h3>

The compiled distribution of jburg is in the distribution's bin/jburg.jar file.
The jarfile is only necessary to generate the BURM.

<a name="running"/>
<h3>Generating a BURM with JBurg</h3>

First create a <a href="specification.html">JBurg specification</a>, then
invoke <code>jburg.burg.JBurgMain</code> to generate the corresponding BURM.

<h4>Required parameters</h4>

<ul>
	<li>Name of the specification
	<li>Name of the output file
</ul>

<h4>Optional parameters</h4>
<ul>
	<li>-g debugging flag
	<br>When -g is set, the generated BURM contains <a href="#debugging">debugging</a> code.
</ul>

<h4>Example ANT task that generates a BURM</h4>
<pre>
	&lt;target name="reducer"&gt;
		&lt;java classname="jburg.burg.JBurgMain" failonerror="yes" fork="yes" dir="reducer"&gt;
			&lt;arg value="MyLanguage.jbg"/&gt;
			&lt;arg value="MyLanguageTreeParser.java"/&gt;
			<font color="green">&lt;!-- &lt;arg value="-g"/&gt; --&gt;</font>
			&lt;classpath&gt;
				&lt;pathelement path="${jburg.jar}"/&gt;
				&lt;pathelement path="${ANTLR.jar}"/&gt;
			&lt;/classpath&gt;
		&lt;/java&gt;
	&lt;/target&gt;
</pre>


<hr>
<a name="integration"/>
<h3>Integrating the generated BURM into your compiler</h3>

<h4>Required data structures</h4>

JBurg's generated BURMs work on a n-ary tree generated by other
passes of the compiler.

The object class that represents a tree node 
(the "INode class")
must provide the following methods:

<ul>
	<li><font color="blue">int</font> <b><code>getOperator()</code></b>
	<br><b>Returns:</b>
	a numeric designation of the node's operator type (e.g., PLUS).
	The generated BURM can implement multiple interfaces that contain symbolic 
	names for these operators.
	<p>
	<li><b><code>int getArity()</code></b>
	<br><b>Returns:</b>
	The number of children this INode has.  Children should be presented
    as a densely indexed sequence.
	<p>
	<li><i>INode class</i> <b><code>getNthChild(int index)</code></b>
	<br><b>Returns:</b>
	This INode' child at position <b><code>index</code></b>.
</ul>

<a name="BURMProperties">
<h4>Setting properties in the generated BURM</h4>

<p>Use the <code>BURMProperty</code> JBurg specification directive
to include a property in your generated BURM.
For example, to include a BCEL ClassGen object as the property classGen:
<dir><code>BURMProperty org.apache.bcel.generic.ClassGen classGen;</code></dir>

<p>JBurg will include a field of the specified type and get/set methods.


<hr>
<a name="debugging"/>
<h3>Debugging your generated BURM</h3>
<p>Debugging a BURM is not too different from debugging any other
Java code.
The <a href="theory.html">theory</a> page will help you understand 
the structure and control flow of the BURM.

<h4>Usual BURM failure modes</h4>

<a name="unmatchedRule">
<h5>Unable to find a rule to process x(22){-1}</h5>

<p>The BURM throws this exception if it cannot find any rule to
match a particular node.  The elements of the diagnostic line are:
<ul>
	<li>Unable to find a rule to process <b>x</b>(22){-1}</h5>
	<br>This is the INode's string representation of itself, from the INode's toString() method.

	<li>Unable to find a rule to process x(<b>22</b>){-1}</h5>
	<br>This is the INode's operator, from the INode's getOperator() method.

	<li>Unable to find a rule to process x(22){<b>-1</b>}</h5>
	<br>This is the goal state the BURM was attempting to satisfy.
	Goal state -1 tells the BURM to "use any available goal."
</ul>

<p>The most common causes of this exception are:
<ul>
	<li>"Type conversion" problems.
	<p>For example, suppose the BURM is trying to reduce <code><b>a + 1</b></code>
	and it has the following rules:
	<dir><pre><code>
	int_value = PLUS(int_value, int_value): 1 { ... }
	int_value = INTEGER_LITERAL(void): 1 { ... }
	obj_value = IDENTIFIER(void) : 5 { ... }
	</code></pre></dir>

	In this case, the BURM will not be able to match the PLUS pattern,
	because there is no rule that allows PLUS to accept an object and 
	an int.

	<p>
	The solution is to add a rule that allows the BURM to transform
	an object into an int:
	<dir><pre><code>
	int_value = obj_value: 5
	{
		<font color="green">//  Call Integer.parseInt(obj.toString)), or something similar.</font>
	}
	</code></pre></dir>

	<p>
	<li>Omitting a rule to handle a particular node type.
</ul>

<h4>BURM debug option output</h4>
<p>Your BURM will support emitting XML-formatted 
debugging information if you generate it
with the JBurg <code><b>-g</b></code> command-line switch.

<p>Debugging output can be written by including a default
error handler, for example:
<xmp>
/*
 *  Error recovery routine: deduce what we can from the problem
 *  tree, then abort this BURM with an exception that the caller
 *  can catch and report.
 */
DefaultErrorHandler
{
    dump(p, "/tmp/failedBurm.xml");
    throw new IllegalStateException("see debugging output in /tmp/failedBurm.xml");
}

</xmp>

<p>Build ErrorAnalyzer.jar from the ant build target:<br>
<code>ant ErrorAnalyzer.jar</code>
and then run the error analyzer against the debugging output:<br>
<code>java -jar lib/ErrorAnalyzer.jar /tmp/failedBurm.xml</code>

<h5>Debug Information</h5>
The error analyzer presents the annotated tree that caused the failure.

<hr>
<a name="modifying"/>
<h3>Notes on modifying JBurg</h3>


<a name="rebuilding"/>
<h4>Rebuilding JBurg</h4>

<p>JBurg's build is ant-based.
The default ant target compiles the Java files and builds <code>jburg.jar</code>.

<p>The files that make up JBurg are:
<ul>
	<li>
		The ANTLR grammar, which also contains JBurg's <code>main()</code> method,
		in <code>grammars/jburg.g</code>.
	<p>Java files generated by ANTLR are:
	<ul>
		<li>JBurgANTLRLexer.java  
		<li>JBurgParser.java  
		<li>JBurgTokenTypes.java
	</ul>
	<p><li>JBurgGenerator.java  

<p>JBurgGenerator.java contains the code that creates the actual BURM.
</ul>

<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/jburg/" : "http://sourceforge.net/apps/piwik/jburg/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://sourceforge.net/apps/piwik/jburg/piwik.php?idsite=1" style="border:0" alt=""/></p></noscript>
<!-- End Piwik Tag -->

