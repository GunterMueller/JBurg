delimiters "%","%"

// ** Start State **
start(table, semantics, includes, uniqueStates) ::= <<
%classDef(table, semantics, includes, uniqueStates)%
>>

// ** Property Access **
className() ::= <<%"";format="class.name"%>>

grammar() ::= <<%"";format="grammar.name"%>>

nodeClass() ::= <<%"";format="node.class"%>>

nodeTypeClass() ::= <<%"";format="nodeType.class"%>>

nonterminalClass() ::= <<%"";format="nonterminal.class"%>>

resultType() ::= <<%"";format="result.type"%>>

timestamp() ::=<<%"";format="timestamp"%>>

version() ::= <<%"";format="version"%>>

visitorClass() ::= <<%"";format="visitor.class"%&>>

// ** Table Translation, mostly alphabetical **
assignState(methods) ::= <<
%if(methods.empty)%
node->setStateNumber(%s.statesByMethod.(methods).stateNumber%);
node->setTransitionTableLeaf(this);
%else%
%methods: { m | bool %m:predicateResult()% = %m:predicateInvocation()%; };separator="\n"%
%s.statesByMethod:predicatedState()%
%endif%
>>

classDef(table, semantics, includes, uniqueStates) ::= <<
/* GENERATED CODE - Edits will be lost
 * Generated by JBurg3 %version()% %timestamp()% %grammar()%
 */

%includes;format="include"%
#include <stdexcept>

namespace jburg {
    int getStateNumber(%nodeClass()%* node) {
        return node? node->getStateNumber():jburg::NullStateNumber;
    }
}

void %className()%::label(%visitorClass()% visitor, %nodeClass()%* node)
{
    if (node) {

        for (size_t i = 0; i < node->getSubtreeCount(); i++) {
            label(visitor, node->getSubtree(i));
        }

        switch(node->getNodeType()) {
            %productionTable(table)%
            default:
                node->setStateNumber(jburg::ErrorStateNumber);
                break;
        }
    }
}

%resultType()% %className()%::reduce(%visitorClass()% visitor, %nodeClass()%* node, %nonterminalClass()% goalState)
{
    if (node) {
        %className()%::TransitionEntry* ti = (%className()%::TransitionEntry*)(node->getTransitionTableLeaf());
        if (ti) {
            return ti->reduce(*this, visitor, node, goalState);
        } else {
            return errorHandler.reduce(visitor, node, goalState);
        }
    } else {
        %table.nullPointerState:nullPointerHandler()%
        return errorHandler.reduce(visitor, node, goalState);
    }
}

bool %className()%::canProduce(%nodeClass()%* node,  %nonterminalClass()% goalState)
{
    if (node != NULL && node->getTransitionTableLeaf() != NULL) {
        TransitionEntry* ti = (TransitionEntry*)(node->getTransitionTableLeaf());
        return ti->canProduce(node, goalState);
    } else {
        return false;
    }
}
%labelRoutines(table)%

%uniqueStates:leafClassDeclaration();separator="\n\n"%
%uniqueStates:leafDefinition();separator="\n\n"%

%errorState(table.errorState)%
>>

errorClosure(c) ::= <<
} else if (goalState == %nonterminalClass()%::%c.nonterminal%) {
    %resultType()% result = reduce(visitor, node, %nonterminalClass()%::%c.source%);
    %if(c.postCallback)%
    result = visitor.%c.postCallback;format="closurePostCallback"%;
    %endif%
    return result;
>>

errorState(s) ::= <<
%resultType()% %className()%::ErrorHandler::reduce(%visitorClass()% visitor, %nodeClass()%* node, %nonterminalClass()% goalState)
{
    %if(s.nonterminal)%
    %resultType()% result;
    if (goalState == %nonterminalClass()%::%s.nonterminal%) {
        return visitor.%s.patterns.(s.nonterminal).preCallback.name%(node, goalState);
    %s.closures.values:errorClosure();separator="\n"%
    }
    %endif%

    throw std::logic_error("unhandled tree parse failure");
}

%table.nonterminals:typedErrorReduction();separator="\n"%

%className()%::ErrorHandler %className()%::errorHandler;
>>

typedErrorReduction(nt) ::= <<
%if(s.viableNonterminals.(nt))%
%nt;format="nonterminal.mapping"% %className()%::ErrorHandler::reduce_as_%nt%(%visitorClass()% visitor, %nodeClass()%* node)
{
    %nt;format="nonterminal.mapping"% result;
    result = visitor.%s.patterns.(s.nonterminal).preCallback.name%(node, %nonterminalClass()%::%nt%);
    /* FIXME: Check closures!
    %s.closures.values:errorClosure();separator="\n"%
    */
    return result;
}
%else%
%nt;format="nonterminal.mapping"% %className()%::ErrorHandler::reduce_as_%nt%(%visitorClass()%, %nodeClass()%*)
{
    throw std::logic_error("unhandled tree parse failure");
}
%endif%
>>

labelRoutine(op) ::= <<
void %className()%::%op:operatorSignature()%(%visitorClass()% visitor, %nodeClass()%* node)
{
    %if(op.transitionTable)%
    %transitionTable(op.transitionTable)%
    %else%
    %leafReference(op.leafState)%
    %endif%
}
>>

labelRoutines(t) ::= <<
%t.operatorsByNodeType:{ nt | %t.operatorsByNodeType.(nt): { op | %labelRoutine(op);separator="\n\n"% };separator="\n\n"% };separator="\n\n"%
>>

leafDefinition(s) ::= <<
%className()%::TransitionEntry* %className()%::%s:leafStateName()% = new %s:leafStateName()%Impl();
>>

leafClassDeclaration(s) ::= <<
// %s%
class %s:leafStateName()%Impl: public %className()%::TransitionEntry
{
    virtual void assignState(%visitorClass()% visitor, %nodeClass()%* node)
    {
        %s.statesByMethod:assignState()%
    }

    virtual %resultType()% reduce(%className()%& reducer, %visitorClass()% visitor, %nodeClass()%* node, %nonterminalClass()% goalState)
    {
        %resultType()% result;

        switch(goalState) {
            %s.statesByMethod:{ m | %s.statesByMethod.(m):reducer();separator="\n"%}%
            default: {
                result = reducer.errorHandler.reduce(visitor, node, goalState);
            }
        }

        return result;
    }

    virtual bool canProduce(%nodeClass()%* node, %nonterminalClass()% goalState)
    {
        switch(goalState) {
            %s.statesProducingNonterminal:canProduceNt();separator="\n"%
            default: return false;
        }
    }

    %s.statesProducingNonterminal:typedReduction();separator="\n"%
};
>>

typedReduction(nt) ::= <<
%nt;format="nonterminal.mapping"% reduce_as_%nt%(%className()%& reducer, %visitorClass()% visitor, %nodeClass()%* node)
{
    %nt;format="nonterminal.mapping"% result;
    if (node) {
        switch(node->getStateNumber()) {
            %s.statesByMethod:{ m | %s.statesByMethod.(m):typedPredicated();separator="\n"%}%
            default: {
                result = %className()%::errorHandler.reduce_as_%nt%(visitor, node);
            }
        }
    } else {
        %if(table.nullPointerState.viableNonterminals.(nt))%
        %nt:nullCase()%
        %else%
        result = %className()%::errorHandler.reduce_as_%nt%(visitor, node);
        %endif%
        return result;
    }

    return result;
}
>>

canProduceNt(nt) ::= <<
case %nonterminalClass()%::%nt%:
    switch (node->getStateNumber()) {
    %s.statesProducingNonterminal.(nt): { stateNumber |case %stateNumber%: };separator="\n"%
        return true;
    default:
        return false;
    }
>>

leafReference(s) ::= <<
%s:leafStateName()%->assignState(visitor, node);
>>

leafStateName(s) ::=<<%s;format="leafState"%>>

nodeOperators(nodeType, operatorList) ::= <<
case %nodeTypeClass()%::%nodeType%:
    switch(node->getSubtreeCount()) {
        %operatorList:operatorDefinition();separator="\n"%
    }
    break;
>>

nullCase(nt) ::= <<
%if(table.nullPointerState.patterns.(nt))%
    %resultType()% result;
    %reduction(table.nullPointerState.patterns.(nt))%
    return result;
%elseif (table.nullPointerState.closures.(nt))%
    %resultType()% result = reduce(visitor, node, %nonterminalClass()%::%table.nullPointerState.closures.(nt).source%);
    %if(table.nullPointerState.closures.(nt).postCallback)%
    result = visitor.%table.nullPointerState.closures.(nt).postCallback;format="closurePostCallback"%;
    %endif%
    return result;
%endif%
>>

untypedNullCase(nt) ::= <<
if (goalState == %nonterminalClass()%::%nt%) {
%if(table.nullPointerState.patterns.(nt))%
    %resultType()% %reduction(table.nullPointerState.patterns.(nt))%
    return result;
%elseif (table.nullPointerState.closures.(nt))%
    %resultType()% result = reduce(visitor, node, %nonterminalClass()%::%table.nullPointerState.closures.(nt).source%);
    %if(table.nullPointerState.closures.(nt).postCallback)%
    result = visitor.%table.nullPointerState.closures.(nt).postCallback;format="closurePostCallback"%;
    %endif%
    return result;
%endif%
}
>>

nullPointerHandler(s) ::= <<
%table.nullPointerState.nonterminals:untypedNullCase();separator="\n"%
>>

operatorDefinition(op) ::= <<
%if(op.variadic)%
default:
    if (node->getSubtreeCount() >= %op.size%) {
        %op:operatorSignature()%(visitor, node);
    }
%else%
case %op.size%:
    %op:operatorSignature()%(visitor, node);
%endif%
    break;
>>

operatorSignature(op) ::= <<%op;format="operatorSignature"%>>

predicatedState(key) ::= <<
if (%key:predicateResult();separator=" && "%) {
    node->setStateNumber(%s.statesByMethod.(key).stateNumber%);
    node->setTransitionTableLeaf(this);
}
>>

predicateInvocation(m) ::= <<
visitor.%m.name%(node)
>>

predicateResult(m) ::= <<
b%m.name%
>>

productionTable(t) ::= <<
%t.operatorsByNodeType:{ nt | %nodeOperators(nt, t.operatorsByNodeType.(nt))% }; separator="\n"%
>>

reducer(s) ::= <<
%s.nonterminals:reduceCase();separator="\n"%
>>

reduceCase(nt) ::= <<
case %nonterminalClass()%::%nt%: {
%if(s.patterns.(nt))%
    %reduction(s.patterns.(nt))%
%elseif (s.closures.(nt))%
    %s.closurePreProductions.(nt): { production | %production.preCallback% };separator="\n * "%
    %reduction(s.patterns.(s.closurePatternPrecursor.(nt)))%
    %s.closurePostProductions.(nt): { production | result = visitor.%production;format="postCallback"% };separator="\n"%
%else%
%endif%
    break;
}
>>

typedPredicated(s) ::= <<
case %s.stateNumber%: {
    %nt:typedReduceCase()%
    break;
}
>>

typedReduceCase(nt) ::= << {
%if(s.patterns.(nt))%
    %reduction(s.patterns.(nt))%
%elseif (s.closures.(nt))%
    %s.closurePreProductions.(nt): { production | %production.preCallback% };separator="\n * "%
    %reduction(s.patterns.(s.closurePatternPrecursor.(nt)))%
    %s.closurePostProductions.(nt): { production | result = visitor.%production;format="postCallback"% };separator="\n"%
%else%
    // No reduction for %nt% in %s%
%endif%
    break;
}
>>

reduction(pattern) ::= <<
%if(pattern.preCallback)%
visitor.%pattern.preCallback.name%(node, goalState);
%endif%
%pattern.nonVariadicChildDescriptors: { c | %resultType()% result%c.position% = reducer.reduce(visitor, node->getSubtree(%c.position%), %nonterminalClass()%::%c.nonterminal%);};separator="\n"%
%if(pattern.isVarArgs)%
std::vector<%resultType()%> variadicActuals;
for (int i = 0; i < node->getSubtreeCount() - %pattern;format="postCallback.variadicOffset"%; i++) {
    variadicActuals.push_back(reducer.reduce(visitor, node->getSubtree(i + %pattern;format="postCallback.variadicOffset"%), %nonterminalClass()%::%pattern.variadicNonterminal%));
}
%endif%
%if(pattern.postCallback)%
result=visitor.%pattern.postCallback;format="postCallback"%;
%else%
// No post callback...
%endif%
>>

transitionTable(t) ::= <<
%if(t.nextDimension.empty)%
switch(jburg::getStateNumber(node->getSubtree(%t.dimension%))) {
%t.normalizedFinalDimension:transitionTableLeaf();separator="\n"%
}
%else%
switch(jburg::getStateNumber(node->getSubtree(%t.dimension%))) {
%t.nextDimIndexMap:{ s | case %s%:
    %transitionTable(t.nextDimensionByIndex.(s))%};separator="break;\n"%
}
%endif%
>>

transitionTableLeaf(leafReferences) ::= <<
%leafReferences: { ref |
    %ref.stateNumbers: { index | case %index%: };separator="\n"%
        %leafReference(ref.reference)%
        break;
}%
>>
