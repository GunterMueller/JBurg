delimiters "%","%"

// ** Start State **
start(table, semantics, includes, uniqueStates) ::= <<
%classDef(table, semantics, uniqueStates)%
>>

// ** Property Access **
className() ::= <<%"";format="class.name"%>>

grammar() ::= <<%"";format="grammar.name"%>>

nodeClass() ::= <<%"";format="node.class"%*>>

nodeTypeClass() ::= <<%"";format="nodeType.class"%>>

nonterminalClass() ::= <<%"";format="nonterminal.class"%>>

resultType() ::= <<%"";format="result.type"%>>

timestamp() ::=<<%"";format="timestamp"%>>

version() ::= <<%"";format="version"%>>

visitorClass() ::= <<%"";format="visitor.class"%&>>

// ** Table Translation, mostly alphabetical **

classDef(table, semantics, uniqueStates) ::= <<
/* GENERATED CODE - Edits will be lost
 * Generated by JBurg3 %version()% %timestamp()% %grammar()%
 */

%includes;format="include"%

class %className()%
{
public:
    void label(%visitorClass()% visitor, %nodeClass()% node);

    %resultType()% reduce(%visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState);

    %table.nonterminals: { nt | %nt;format="nonterminal.mapping"% reduce_as_%nt%(%visitorClass()%, %nodeClass()%); };separator="\n"%

    bool canProduce(%nodeClass()% node,  %nonterminalClass()% goalState);

private:
    %errorState(table.errorState)%

    class TransitionEntry
    {

    public:
        virtual void assignState(%visitorClass()% visitor, %nodeClass()% node) = 0;
        virtual %resultType()% reduce(%className()%& reducer, %visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState) = 0;
        virtual bool canProduce(%nodeClass()% node, %nonterminalClass()% goalState) = 0;

        %table.nonterminals:typedReductionDecl();separator="\n\n"%
    };
private:
    %labelRoutines(table)%

    %uniqueStates:leafDefinition();separator="\n"%
};

namespace jburg {
    static const int ErrorStateNumber = 0;
    static const int NullStateNumber = 1;
}
>>

errorState(s) ::= <<
class ErrorHandler
{
public:
    %resultType()% reduce(%visitorClass()% visitor, %nodeClass()% node, %nonterminalClass()% goalState);
    %table.nonterminals: { nt | %nt;format="nonterminal.mapping"% reduce_as_%nt%(%visitorClass()%, %nodeClass()%); };separator="\n"%
};

public:
static ErrorHandler errorHandler;
>>

labelRoutine(op) ::= <<
void %op:operatorSignature()%(%visitorClass()% visitor, %nodeClass()% node);
>>

labelRoutines(t) ::= <<
%t.operatorsByNodeType:{ nt | %t.operatorsByNodeType.(nt): { op | %labelRoutine(op);separator="\n\n"% };separator="\n\n"% };separator="\n\n"%
>>

leafDefinition(s) ::= <<
// %s%
static TransitionEntry* %s:leafStateName()%;
>>

operatorSignature(op) ::= <<%op;format="operatorSignature"%>>

leafStateName(s) ::=<<%s;format="leafState"%>>

typedReductionDecl(nt) ::= <<
virtual %nt;format="nonterminal.mapping"% reduce_as_%nt%(%className()%& reducer, %visitorClass()% visitor, %nodeClass()% node)
{
    return reducer.reduce(visitor, node, %nonterminalClass()%::%nt%);
}
>>
